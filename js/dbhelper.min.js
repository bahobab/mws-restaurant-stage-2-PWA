const DB_NAME='restaurantReviews';const DB_VER=1;const RESTAURANT_STORE='Restaurants';const OpenIDB=createIndexedDB(DB_NAME,DB_VER);function createIndexedDB(dbName,dbVer){return idb.open(dbName,dbVer,function(upgradeDb){if(!upgradeDb.objectStoreNames.contains(RESTAURANT_STORE)){const restaurantStore=upgradeDb.createObjectStore(RESTAURANT_STORE,{keyPath:'id'})}})}
function saveToIndexedDB(openDB,storeName,data){openDB.then(db=>{const transaction=db.transaction(storeName,'readwrite');store=transaction.objectStore(storeName);try{data.forEach(restaurant=>store.put(restaurant))}catch(error){}
return transaction.complete})}
function readFromIndexedDB(openDB,storeName,typeOfData){return openDB.then(db=>db.transaction(storeName).objectStore(storeName).getAll())}
class DBHelper{static get DATABASE_URL(){const port=8081
return `http://localhost:1337/restaurants`}
static async fetchRestaurants(callback){try{const response=await fetch(DBHelper.DATABASE_URL);const restaurants=await response.json();saveToIndexedDB(OpenIDB,RESTAURANT_STORE,restaurants);callback(null,restaurants)}catch(err){const restaurants=await readFromIndexedDB(OpenIDB,RESTAURANT_STORE,'all');callback(null,restaurants);const error=(`Request failed. Returned status of ${err}`);callback(error,null)}}
static fetchRestaurantById(id,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const restaurant=restaurants.find(r=>r.id==id);if(restaurant){callback(null,restaurant)}else{callback('Restaurant does not exist',null)}}})}
static fetchRestaurantByCuisine(cuisine,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const results=restaurants.filter(r=>r.cuisine_type==cuisine);callback(null,results)}})}
static fetchRestaurantByNeighborhood(neighborhood,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const results=restaurants.filter(r=>r.neighborhood==neighborhood);callback(null,results)}})}
static fetchRestaurantByCuisineAndNeighborhood(cuisine,neighborhood,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{let results=restaurants
if(cuisine!='all'){results=results.filter(r=>r.cuisine_type==cuisine)}
if(neighborhood!='all'){results=results.filter(r=>r.neighborhood==neighborhood)}
callback(null,results)}})}
static fetchNeighborhoods(callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const neighborhoods=restaurants.map((v,i)=>restaurants[i].neighborhood)
const uniqueNeighborhoods=neighborhoods.filter((v,i)=>neighborhoods.indexOf(v)==i)
callback(null,uniqueNeighborhoods)}})}
static fetchCuisines(callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const cuisines=restaurants.map((v,i)=>restaurants[i].cuisine_type)
const uniqueCuisines=cuisines.filter((v,i)=>cuisines.indexOf(v)==i)
callback(null,uniqueCuisines)}})}
static urlForRestaurant(restaurant){return(`./restaurant.html?id=${restaurant.id}`)}
static imageUrlForRestaurant(restaurant){if(restaurant.photograph){return `/img/dest/webp/${restaurant.photograph}-md_1x.webp`}
return `/img/dest/webp/not-a-restaurant.webp`}
static mapMarkerForRestaurant(restaurant,map){const marker=new google.maps.Marker({position:restaurant.latlng,title:restaurant.name,url:DBHelper.urlForRestaurant(restaurant),map:map,animation:google.maps.Animation.DROP});return marker}}